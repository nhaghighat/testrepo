/**
 * A {@link SugiyamaOperator} for computing a layered layout of a dag
 *
 * @module
 */
import { CoordOperator } from "./coord";
import { Dag, DagNode } from "../dag";
import { GroupAccessor, LayeringOperator, RankAccessor } from "./layering";
import { LinkDatum, NodeDatum, SugiDataDagNode, SugiNode } from "./utils";
import { QuadOperator } from "./coord/quad";
import { SimplexOperator } from "./layering/simplex";
import { TwoLayerOperator } from "./decross/two-layer";
import { Up } from "../utils";
import { AggOperator } from "./twolayer/agg";
import { DecrossOperator } from "./decross";
/**
 * The return from calling {@link SugiyamaOperator}
 *
 * This is the final width and height of the laidout dag.
 */
export interface SugiyamaInfo {
    width: number;
    height: number;
}
/**
 * An accessor for computing the size of a node in the layout
 *
 * If `node` is omitted, the returned size is the size of a "dummy node", a
 * piece of a long edge that can curve around other nodes. This accessor must
 * return a tuple of non-negative numbers corresponding to the node's *width*
 * and *height*. Since this is a layered layout, a node's height is effectively
 * the maximum height of all nodes in the same layer.
 *
 * If you need more control over the size of dummy nodes, see
 * {@link SugiNodeSizeAccessor}.
 *
 * This accessor will only be called once for each node.
 */
export interface NodeSizeAccessor<NodeDatum = never, LinkDatum = never> {
    (node?: DagNode<NodeDatum, LinkDatum>): readonly [number, number];
}
/**
 * An accessor for computing the size of a node in the layout
 *
 * This interface exposes a full {@link SugiNode}, which has more information
 * about dummy nodes availble in case different dummy nodes should have
 * different sizes.
 *
 * For most cases {@link NodeSizeAccessor} should be enough.
 */
export interface SugiNodeSizeAccessor<NodeDatum = never, LinkDatum = never> {
    (node: SugiNode<NodeDatum, LinkDatum>): readonly [number, number];
}
declare type NsDagNode<NS extends NodeSizeAccessor> = Exclude<Parameters<NS>[0], undefined>;
declare type NsNodeDatum<NS extends NodeSizeAccessor> = NodeDatum<NsDagNode<NS>>;
declare type NsLinkDatum<NS extends NodeSizeAccessor> = LinkDatum<NsDagNode<NS>>;
/**
 * The effective {@link SugiNodeSizeAccessor} when a normal
 * {@link NodeSizeAccessor} is supplied.
 */
export interface WrappedNodeSizeAccessor<NodeSize extends NodeSizeAccessor> extends SugiNodeSizeAccessor<NsNodeDatum<NodeSize>, NsLinkDatum<NodeSize>> {
    wrapped: NodeSize;
}
interface Operators {
    layering: LayeringOperator;
    decross: DecrossOperator;
    coord: CoordOperator;
    nodeSize: NodeSizeAccessor | null;
    sugiNodeSize: SugiNodeSizeAccessor;
}
declare type LDagNode<Op extends LayeringOperator> = ReturnType<Parameters<Op>[0]["roots"]>[number];
declare type OpDagNode<Op extends DecrossOperator | CoordOperator> = SugiDataDagNode<Parameters<Op>[0][number][number]["data"]>;
declare type SNSDagNode<Op extends SugiNodeSizeAccessor> = SugiDataDagNode<Parameters<Op>[0]["data"]>;
declare type OpsDag<Ops extends Operators> = Dag<NodeDatum<LDagNode<Ops["layering"]>> & NodeDatum<OpDagNode<Ops["decross"]>> & NodeDatum<OpDagNode<Ops["coord"]>> & NodeDatum<SNSDagNode<Ops["sugiNodeSize"]>>, LinkDatum<LDagNode<Ops["layering"]>> & LinkDatum<OpDagNode<Ops["decross"]>> & LinkDatum<OpDagNode<Ops["coord"]>> & LinkDatum<SNSDagNode<Ops["sugiNodeSize"]>>>;
/**
 * The operator used to layout a {@link Dag} using the sugiyama layered method.
 *
 * The algorithm is roughly comprised of three steps:
 * 1. {@link LayeringOperator | layering} - in this step, every node is
 *    assigned a non-negative integer later such that children are guaranteed
 *    to have higher layers than their parents. (modified with {@link layering})
 * 2. {@link DecrossOperator | decrossing} - in the step, nodes in each layer
 *    are reordered to minimize the number of crossings. (modified with {@link
 *    decross})
 * 3. {@link CoordOperator | coordinate assignment} - in the step, the
 *    nodes are assigned x and y coordinates that respect their layer, layer
 *    ordering, and size. (modified with {@link coord} and {@link nodeSize})
 *
 * The algorithm is based off ideas presented in K. Sugiyama et al. [1979], but
 * described by {@link http://www.it.usyd.edu.au/~shhong/fab.pdf | S. Hong}.
 * The sugiyama layout can be configured with different algorithms for each
 * stage of the layout. For each stage there should be adecuate choices for
 * methods that balance speed and quality for your desired layout. In the
 * absence of those, any function that meets the interface for that stage is
 * valid.
 *
 * Create with {@link sugiyama}.
 *
 * <img alt="Sugiyama example" src="media://sugi-simplex-opt-quad.png" width="400">
 */
export interface SugiyamaOperator<Ops extends Operators = Operators> {
    /**
     * Layout the {@link Dag} using the currently configured operator. The
     * returned dag nodes will have `x`, `y`, and `value` (layer), assigned. In
     * addition, each link will have `points` assigned to the current layout.
     */
    (dag: OpsDag<Ops>): SugiyamaInfo;
    /**
     * Set the {@link LayeringOperator}. (default: {@link SimplexOperator})
     */
    layering<NewLayering extends LayeringOperator>(layer: NewLayering): SugiyamaOperator<Up<Ops, {
        layering: NewLayering;
    }>>;
    /**
     * Get the current {@link LayeringOperator}.
     */
    layering(): Ops["layering"];
    /**
     * Set the {@link DecrossOperator}. (default: {@link TwoLayerOperator})
     */
    decross<NewDecross extends DecrossOperator>(dec: NewDecross): SugiyamaOperator<Up<Ops, {
        decross: NewDecross;
    }>>;
    /**
     * Get the current {@link DecrossOperator}.
     */
    decross(): Ops["decross"];
    /**
     * Set the {@link CoordOperator}. (default: {@link QuadOperator})
     */
    coord<NewCoord extends CoordOperator>(crd: NewCoord): SugiyamaOperator<Up<Ops, {
        coord: NewCoord;
    }>>;
    /**
     * Get the current {@link CoordOperator}.
     */
    coord(): Ops["coord"];
    /**
     * Sets the sugiyama layout's size to the specified two-element array of
     * numbers [ *width*, *height* ].  When `size` is non-null the dag will be
     * shrunk or expanded to fit in the size, keeping all distances proportional.
     * If it's null, the {@link nodeSize} parameters will be respected as
     * coordinate sizes. (default: null)
     */
    size(sz: readonly [number, number] | null): SugiyamaOperator<Ops>;
    /**
     * Get the current layout size.
     */
    size(): null | readonly [number, number];
    /**
     * Sets the {@link NodeSizeAccessor}, which assigns how much space is
     * necessary between nodes. (defaults to [1, 1] for normal nodes and [0, 0]
     * for dummy nodes)
     */
    nodeSize<NewNodeSize extends NodeSizeAccessor>(acc: NewNodeSize): SugiyamaOperator<Up<Ops, {
        nodeSize: NewNodeSize;
        sugiNodeSize: WrappedNodeSizeAccessor<NewNodeSize>;
    }>>;
    /**
     * Get the current node size
     *
     * If a {@link SugiNodeSizeAccessor} was specified, this will be null.
     */
    nodeSize(): Ops["nodeSize"];
    /**
     * Sets this sugiyama layout's {@link SugiNodeSizeAccessor}.
     *
     * This is effectively a more powerful api above the standard
     * {@link NodeSizeAccessor}, and is only necessary if different dummy nodes
     * need different sizes.
     */
    sugiNodeSize<NewSugiNodeSize extends SugiNodeSizeAccessor>(sz: NewSugiNodeSize): SugiyamaOperator<Up<Ops, {
        sugiNodeSize: NewSugiNodeSize;
        nodeSize: null;
    }>>;
    /**
     * Get the current sugi node size, or a {@link WrappedNodeSizeAccessor |
     * wrapped version} if {@link nodeSize} was specified.
     */
    sugiNodeSize(): Ops["sugiNodeSize"];
}
/**
 * Construct a new {@link SugiyamaOperator} with the default settings.
 */
export declare function sugiyama(...args: never[]): SugiyamaOperator<{
    layering: SimplexOperator<{
        rank: RankAccessor<unknown, unknown>;
        group: GroupAccessor<unknown, unknown>;
    }>;
    decross: TwoLayerOperator<AggOperator>;
    coord: QuadOperator;
    nodeSize: NodeSizeAccessor<unknown, unknown>;
    sugiNodeSize: WrappedNodeSizeAccessor<NodeSizeAccessor<unknown, unknown>>;
}>;
export {};
