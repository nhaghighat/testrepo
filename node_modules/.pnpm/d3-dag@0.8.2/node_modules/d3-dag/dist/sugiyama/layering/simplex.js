/**
 * A {@link SimplexOperator} that assigns layers to minimize the number of
 * dummy nodes.
 *
 * @module
 */
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { Solve } from "javascript-lp-solver";
import { assert, bigrams, def } from "../../utils";
/** @internal */
function buildOperator(options) {
    function simplexCall(dag) {
        const variables = {};
        const ints = {};
        const constraints = {};
        const ids = new Map(dag
            .idescendants()
            .entries()
            .map(([i, node]) => [node, i.toString()]));
        /** get node id */
        function n(node) {
            return def(ids.get(node));
        }
        /** get variable associated with a node */
        function variable(node) {
            return variables[n(node)];
        }
        /** enforce that first occurs before second
         *
         * @param prefix determines a unique prefix to describe constraint
         * @param strict strictly before or possibly equal
         */
        function before(prefix, first, second, strict = true) {
            const fvar = variable(first);
            const svar = variable(second);
            const cons = `${prefix}: ${def(n(first))} -> ${def(n(second))}`;
            constraints[cons] = { min: +strict };
            fvar[cons] = -1;
            svar[cons] = 1;
        }
        /** enforce that first and second occur on the same layer */
        function equal(prefix, first, second) {
            before(`${prefix} before`, first, second, false);
            before(`${prefix} after`, second, first, false);
        }
        const ranks = [];
        const groups = new Map();
        // Add node variables and fetch ranks
        for (const node of dag) {
            const nid = n(node);
            ints[nid] = 1;
            variables[nid] = {
                opt: node.children.length
            };
            const rank = options.rank(node);
            if (rank !== undefined) {
                ranks.push([rank, node]);
            }
            const group = options.group(node);
            if (group !== undefined) {
                const existing = groups.get(group);
                if (existing) {
                    existing.push(node);
                }
                else {
                    groups.set(group, [node]);
                }
            }
        }
        // Add link constraints
        for (const link of dag.ilinks()) {
            before("link", link.source, link.target);
            ++variable(link.source).opt;
            --variable(link.target).opt;
        }
        // Add rank constraints
        const ranked = ranks.sort(([a], [b]) => a - b);
        for (const [[frank, fnode], [srank, snode]] of bigrams(ranked)) {
            if (frank < srank) {
                before("rank", fnode, snode);
            }
            else {
                equal("rank", fnode, snode);
            }
        }
        // group constraints
        for (const group of groups.values()) {
            for (const [first, second] of bigrams(group)) {
                equal("group", first, second);
            }
        }
        // NOTE bundling sets `this` to undefined, and we need it to be setable
        const _a = Solve.call({}, {
            optimize: "opt",
            opType: "max",
            constraints: constraints,
            variables: variables,
            ints: ints
        }), { feasible } = _a, assignment = __rest(_a, ["feasible"]);
        if (!feasible) {
            assert(ranks.length || groups.size);
            throw new Error("could not find a feasbile simplex layout, check that rank or group accessors are not ill-defined");
        }
        // lp solver doesn't assign some zeros
        for (const node of dag) {
            node.value = assignment[n(node)] || 0;
        }
    }
    function rank(newRank) {
        if (newRank === undefined) {
            return options.rank;
        }
        else {
            const { rank: _ } = options, rest = __rest(options, ["rank"]);
            return buildOperator(Object.assign(Object.assign({}, rest), { rank: newRank }));
        }
    }
    simplexCall.rank = rank;
    function group(newGroup) {
        if (newGroup === undefined) {
            return options.group;
        }
        else {
            const { group: _ } = options, rest = __rest(options, ["group"]);
            return buildOperator(Object.assign(Object.assign({}, rest), { group: newGroup }));
        }
    }
    simplexCall.group = group;
    return simplexCall;
}
/** @internal */
function defaultAccessor() {
    return undefined;
}
/**
 * Create a default {@link SimplexOperator}, bundled as {@link layeringSimplex}.
 */
export function simplex(...args) {
    if (args.length) {
        throw new Error(`got arguments to simplex(${args}), but constructor takes no aruguments.`);
    }
    return buildOperator({ rank: defaultAccessor, group: defaultAccessor });
}
