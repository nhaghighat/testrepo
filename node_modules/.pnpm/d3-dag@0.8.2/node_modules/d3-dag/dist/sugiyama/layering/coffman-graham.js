/**
 * A {@link CoffmanGrahamOperator} that prevents the width of the dag from
 * being too large.
 *
 * @module
 */
import FastPriorityQueue from "fastpriorityqueue";
import { def } from "../../utils";
/** @internal */
function buildOperator(options) {
    function coffmanGrahamCall(dag) {
        const maxWidth = options.width || Math.floor(Math.sqrt(dag.size() + 0.5));
        // initialize node data
        const data = new Map(dag
            .idescendants()
            .map((node) => [
            node,
            { before: [], parents: [] }
        ]));
        for (const node of dag) {
            for (const child of node.ichildren()) {
                def(data.get(child)).parents.push(node);
            }
        }
        // create queue
        function comp(left, right) {
            const leftBefore = def(data.get(left)).before;
            const rightBefore = def(data.get(right)).before;
            for (const [i, leftb] of leftBefore.entries()) {
                const rightb = rightBefore[i];
                if (rightb === undefined) {
                    return false;
                }
                else if (leftb < rightb) {
                    return true;
                }
                else if (rightb < leftb) {
                    return false;
                }
            }
            return true;
        }
        const queue = new FastPriorityQueue(comp);
        // start with root nodes
        for (const root of dag.iroots()) {
            queue.add(root);
        }
        let i = 0; // node index
        let layer = 0; // layer assigning
        let width = 0; // current width
        let node;
        while ((node = queue.poll())) {
            if (width < maxWidth &&
                def(data.get(node)).parents.every((p) => def(p.value) < layer)) {
                node.value = layer;
                width++;
            }
            else {
                node.value = ++layer;
                width = 1;
            }
            for (const child of node.ichildren()) {
                const { before, parents } = def(data.get(child));
                before.push(i);
                if (before.length === parents.length) {
                    before.sort((a, b) => b - a);
                    queue.add(child);
                }
            }
            i++;
        }
    }
    function width(maxWidth) {
        if (maxWidth === undefined) {
            return options.width;
        }
        else if (maxWidth < 0) {
            throw new Error(`width must be non-negative: ${maxWidth}`);
        }
        else {
            return buildOperator(Object.assign(Object.assign({}, options), { width: maxWidth }));
        }
    }
    coffmanGrahamCall.width = width;
    return coffmanGrahamCall;
}
/**
 * Create a default {@link CoffmanGrahamOperator}, bundled as
 * {@link layeringCoffmanGraham}.
 */
export function coffmanGraham(...args) {
    if (args.length) {
        throw new Error(`got arguments to coffmanGraham(${args}), but constructor takes no aruguments.`);
    }
    return buildOperator({ width: 0 });
}
