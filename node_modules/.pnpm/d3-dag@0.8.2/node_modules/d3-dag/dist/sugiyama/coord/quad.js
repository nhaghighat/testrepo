import { bigrams, def, dfs, setIntersect } from "../../utils";
import { indices, init, layout, minBend, minDist, solve } from "./utils";
/**
 * Compute a map from node ids to a connected component index. This is useful
 * to quickly compare if two nodes are in the same connected component.
 *
 * @internal
 */
function componentMap(layers) {
    // create parent map to allow accessing parents
    const parents = new Map();
    for (const layer of layers) {
        for (const node of layer) {
            for (const child of node.ichildren()) {
                const pars = parents.get(child);
                if (pars) {
                    pars.push(node);
                }
                else {
                    parents.set(child, [node]);
                }
            }
        }
    }
    // "children" function that returns children and parents
    function* graph(node) {
        yield* node.ichildren();
        yield* parents.get(node) || [];
    }
    // dfs over all nodes
    let component = 0;
    const compMap = new Map();
    for (const layer of layers) {
        for (const node of layer) {
            if (compMap.has(node))
                continue;
            for (const comp of dfs(graph, node)) {
                compMap.set(comp, component);
            }
            component++;
        }
    }
    return compMap;
}
/**
 * If disconnected components exist in the same layer, then we can minimize the
 * distance between them to make a reasonable objective. If, however, layers
 * share no common components then they are truely independent in assignment of
 * x coordinates and should be solved separately.
 *
 * @internal
 */
function splitComponentLayers(layers, compMap) {
    // Because of dummy nodes, there's no way for a component to skip a layer,
    // thus for layers to share no common components, there must be a clear
    // boundary between any two.
    const split = [];
    let newLayers = [];
    let lastComponents = new Set();
    for (const layer of layers) {
        const currentComponents = new Set(layer.map((n) => def(compMap.get(n))));
        if (!setIntersect(lastComponents, currentComponents)) {
            split.push((newLayers = []));
        }
        newLayers.push(layer);
        lastComponents = currentComponents;
    }
    return split;
}
function buildOperator(options) {
    function quadComponent(layers, nodeSize, compMap) {
        const { vertNode, vertDummy, curveNode, curveDummy, comp } = options;
        const inds = indices(layers);
        const [Q, c, A, b] = init(layers, inds, nodeSize);
        for (const layer of layers) {
            for (const par of layer) {
                const pind = def(inds.get(par));
                const wpdist = "node" in par.data ? vertNode : vertDummy;
                for (const node of par.ichildren()) {
                    const nind = def(inds.get(node));
                    const wndist = "node" in node.data ? vertNode : vertDummy;
                    const wcurve = "node" in node.data ? curveNode : curveDummy;
                    minDist(Q, pind, nind, wpdist + wndist);
                    for (const child of node.ichildren()) {
                        const cind = def(inds.get(child));
                        minBend(Q, pind, nind, cind, wcurve);
                    }
                }
            }
        }
        // for disconnected dags, add loss for being too far apart
        for (const layer of layers) {
            for (const [first, second] of bigrams(layer)) {
                if (def(compMap.get(first)) !== def(compMap.get(second))) {
                    minDist(Q, def(inds.get(first)), def(inds.get(second)), comp);
                }
            }
        }
        const solution = solve(Q, c, A, b);
        return layout(layers, nodeSize, inds, solution);
    }
    function quadCall(layers, nodeSize) {
        const { vertNode, vertDummy, curveNode, curveDummy } = options;
        if (vertNode === 0 && curveNode === 0) {
            throw new Error("node vertical weight or node curve weight needs to be positive");
        }
        else if (vertDummy === 0 && curveDummy === 0) {
            throw new Error("dummy vertical weight or dummy curve weight needs to be positive");
        }
        // split components
        const compMap = componentMap(layers);
        const components = splitComponentLayers(layers, compMap);
        // layout each component and get width
        const widths = components.map((compon) => quadComponent(compon, nodeSize, compMap));
        // center components
        const maxWidth = Math.max(...widths);
        if (maxWidth <= 0) {
            throw new Error("must assign nonzero width to at least one node");
        }
        for (const [i, compon] of components.entries()) {
            const offset = (maxWidth - widths[i]) / 2;
            for (const layer of compon) {
                for (const node of layer) {
                    node.x = def(node.x) + offset;
                }
            }
        }
        return maxWidth;
    }
    function vertical(val) {
        if (val === undefined) {
            const { vertNode, vertDummy } = options;
            return [vertNode, vertDummy];
        }
        const [vertNode, vertDummy] = val;
        if (vertNode < 0 || vertDummy < 0) {
            throw new Error(`weights must be non-negative, but were ${vertNode} and ${vertDummy}`);
        }
        else {
            return buildOperator(Object.assign(Object.assign({}, options), { vertNode, vertDummy }));
        }
    }
    quadCall.vertical = vertical;
    function curve(val) {
        if (val === undefined) {
            const { curveNode, curveDummy } = options;
            return [curveNode, curveDummy];
        }
        const [curveNode, curveDummy] = val;
        if (curveNode < 0 || curveDummy < 0) {
            throw new Error(`weights must be non-negative, but were ${curveNode} and ${curveDummy}`);
        }
        else {
            return buildOperator(Object.assign(Object.assign({}, options), { curveNode, curveDummy }));
        }
    }
    quadCall.curve = curve;
    function component(val) {
        if (val === undefined) {
            return options.comp;
        }
        else if (val <= 0) {
            throw new Error(`weight must be positive, but was ${val}`);
        }
        else {
            return buildOperator(Object.assign(Object.assign({}, options), { comp: val }));
        }
    }
    quadCall.component = component;
    return quadCall;
}
/**
 * Create a default {@link QuadOperator}, bundled as {@link coordQuad}.
 */
export function quad(...args) {
    if (args.length) {
        throw new Error(`got arguments to quad(${args}), but constructor takes no aruguments.`);
    }
    return buildOperator({
        vertNode: 1,
        vertDummy: 0,
        curveNode: 0,
        curveDummy: 1,
        comp: 1
    });
}
