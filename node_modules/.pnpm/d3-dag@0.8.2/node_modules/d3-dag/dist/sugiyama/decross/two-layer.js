/**
 * A {@link TwoLayerOperator} heuristic for reducing the number of crossings in
 * large dags efficiently.
 *
 * @module
 */
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { agg } from "../twolayer/agg";
import { bigrams, def } from "../../utils";
// TODO Add optional greedy swapping of nodes after assignment
// TODO Add two layer noop. This only makes sense if there's a greedy swapping ability
/** @internal */
function buildOperator(options) {
    function twoLayerCall(layers) {
        const reversed = layers.slice().reverse();
        let changed = true;
        for (let i = 0; i < options.passes && changed; ++i) {
            changed = false;
            // top down
            for (const [upper, bottom] of bigrams(layers)) {
                const init = new Map(bottom.map((node, i) => [node, i]));
                options.order(upper, bottom, true);
                if (bottom.some((node, i) => def(init.get(node)) !== i)) {
                    changed = true;
                }
            }
            // bottom up
            for (const [lower, topl] of bigrams(reversed)) {
                const init = new Map(topl.map((node, i) => [node, i]));
                options.order(topl, lower, false);
                if (topl.some((node, i) => def(init.get(node)) !== i)) {
                    changed = true;
                }
            }
        }
    }
    function order(ord) {
        if (ord === undefined) {
            return options.order;
        }
        else {
            const { order: _ } = options, rest = __rest(options, ["order"]);
            return buildOperator(Object.assign(Object.assign({}, rest), { order: ord }));
        }
    }
    twoLayerCall.order = order;
    function passes(val) {
        if (val === undefined) {
            return options.passes;
        }
        else if (val <= 0) {
            throw new Error("number of passes must be positive");
        }
        else {
            return buildOperator(Object.assign(Object.assign({}, options), { passes: val }));
        }
    }
    twoLayerCall.passes = passes;
    return twoLayerCall;
}
/**
 * Create a default {@link TwoLayerOperator}, bundled as
 * {@link decrossTwoLayer}.
 */
export function twoLayer(...args) {
    if (args.length) {
        throw new Error(`got arguments to twoLayer(${args}), but constructor takes no aruguments.`);
    }
    return buildOperator({ order: agg(), passes: 1 });
}
