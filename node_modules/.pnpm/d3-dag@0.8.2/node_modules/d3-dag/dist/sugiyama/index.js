/**
 * A {@link SugiyamaOperator} for computing a layered layout of a dag
 *
 * @module
 */
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { sugify } from "./utils";
import { quad } from "./coord/quad";
import { simplex } from "./layering/simplex";
import { twoLayer } from "./decross/two-layer";
import { assert, def, js } from "../utils";
function wrapNodeSizeAccessor(acc) {
    const empty = acc();
    function sugiNodeSizeAccessor(node) {
        return "node" in node.data ? acc(node.data.node) : empty;
    }
    sugiNodeSizeAccessor.wrapped = acc;
    return sugiNodeSizeAccessor;
}
/**
 * A checked and cached node size accessor wrapper.
 *
 * @internal
 */
function cachedNodeSize(nodeSize) {
    const cache = new Map();
    function cached(node) {
        let val = cache.get(node);
        if (val === undefined) {
            val = nodeSize(node);
            const [width, height] = val;
            if (width < 0 || height < 0) {
                throw new Error(js `all node sizes must be non-negative, but got width ${width} and height ${height} for node '${node}'`);
            }
            cache.set(node, val);
        }
        return val;
    }
    const cachedX = (node) => cached(node)[0];
    const cachedY = (node) => cached(node)[1];
    return [cachedX, cachedY];
}
/** @internal */
function buildOperator(options) {
    function sugiyama(dag) {
        // compute layers
        options.layering(dag);
        // create layers
        const layers = sugify(dag);
        // assign y
        const [xSize, ySize] = cachedNodeSize(options.sugiNodeSize);
        let height = 0;
        for (const layer of layers) {
            const layerHeight = Math.max(...layer.map(ySize));
            for (const node of layer) {
                node.y = height + layerHeight / 2;
            }
            height += layerHeight;
        }
        if (height <= 0) {
            throw new Error("at least one node must have positive height, but total height was zero");
        }
        // minimize edge crossings
        options.decross(layers);
        // assign coordinates
        let width = options.coord(layers, xSize);
        // verify
        for (const layer of layers) {
            for (const node of layer) {
                if (node.x === undefined) {
                    throw new Error(js `coord didn't assign an x to node '${node}'`);
                }
                else if (node.x < 0 || node.x > width) {
                    throw new Error(`coord assgined an x (${node.x}) outside of [0, ${width}]`);
                }
            }
        }
        // scale x
        if (options.size !== null) {
            const [newWidth, newHeight] = options.size;
            for (const layer of layers) {
                for (const node of layer) {
                    assert(node.x !== undefined && node.y !== undefined);
                    node.x *= newWidth / width;
                    node.y *= newHeight / height;
                }
            }
            width = newWidth;
            height = newHeight;
        }
        // Update original dag with values
        for (const layer of layers) {
            for (const sugi of layer) {
                assert(sugi.x !== undefined && sugi.y !== undefined);
                if ("target" in sugi.data)
                    continue;
                sugi.data.node.x = sugi.x;
                sugi.data.node.y = sugi.y;
                const pointsMap = new Map(sugi.data.node
                    .ichildLinks()
                    .map(({ points, target }) => [target, points]));
                for (let child of sugi.ichildren()) {
                    const points = [{ x: sugi.x, y: sugi.y }];
                    while ("target" in child.data) {
                        assert(child.x !== undefined && child.y !== undefined);
                        points.push({ x: child.x, y: child.y });
                        [child] = child.ichildren();
                    }
                    assert(child.x !== undefined && child.y !== undefined);
                    points.push({ x: child.x, y: child.y });
                    // update
                    const assign = def(pointsMap.get(child.data.node));
                    assign.splice(0, assign.length, ...points);
                }
            }
        }
        // layout info
        return { width, height };
    }
    function layering(layer) {
        if (layer === undefined) {
            return options.layering;
        }
        else {
            const { layering: _ } = options, rest = __rest(options, ["layering"]);
            return buildOperator(Object.assign(Object.assign({}, rest), { layering: layer }));
        }
    }
    sugiyama.layering = layering;
    function decross(dec) {
        if (dec === undefined) {
            return options.decross;
        }
        else {
            const { decross: _ } = options, rest = __rest(options, ["decross"]);
            return buildOperator(Object.assign(Object.assign({}, rest), { decross: dec }));
        }
    }
    sugiyama.decross = decross;
    function coord(crd) {
        if (crd === undefined) {
            return options.coord;
        }
        else {
            const { coord: _ } = options, rest = __rest(options, ["coord"]);
            return buildOperator(Object.assign(Object.assign({}, rest), { coord: crd }));
        }
    }
    sugiyama.coord = coord;
    function size(sz) {
        if (sz !== undefined) {
            return buildOperator(Object.assign(Object.assign({}, options), { size: sz }));
        }
        else {
            return options.size;
        }
    }
    sugiyama.size = size;
    function nodeSize(sz) {
        if (sz !== undefined) {
            const { nodeSize: _, sugiNodeSize: __ } = options, rest = __rest(options, ["nodeSize", "sugiNodeSize"]);
            return buildOperator(Object.assign(Object.assign({}, rest), { nodeSize: sz, sugiNodeSize: wrapNodeSizeAccessor(sz) }));
        }
        else {
            return options.nodeSize;
        }
    }
    sugiyama.nodeSize = nodeSize;
    function sugiNodeSize(sz) {
        if (sz !== undefined) {
            const { sugiNodeSize: _, nodeSize: __ } = options, rest = __rest(options, ["sugiNodeSize", "nodeSize"]);
            return buildOperator(Object.assign(Object.assign({}, rest), { sugiNodeSize: sz, nodeSize: null }));
        }
        else {
            return options.sugiNodeSize;
        }
    }
    sugiyama.sugiNodeSize = sugiNodeSize;
    return sugiyama;
}
/** @internal */
function defaultNodeSize(node) {
    return [+(node !== undefined), 1];
}
/**
 * Construct a new {@link SugiyamaOperator} with the default settings.
 */
export function sugiyama(...args) {
    if (args.length) {
        throw new Error(`got arguments to sugiyama(${args}), but constructor takes no aruguments.`);
    }
    else {
        return buildOperator({
            layering: simplex(),
            decross: twoLayer(),
            coord: quad(),
            size: null,
            nodeSize: defaultNodeSize,
            sugiNodeSize: wrapNodeSizeAccessor(defaultNodeSize)
        });
    }
}
