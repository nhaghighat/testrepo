var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { fluent } from "../iters";
import { assert, def, dfs, js } from "../utils";
/**********************
 * Dag Implementation *
 **********************/
class LayoutChildLink {
    constructor(child, data, points = []) {
        this.child = child;
        this.data = data;
        this.points = points;
    }
}
/**
 * The concrete class backing the {@link Link} interface.
 */
class LayoutLink {
    constructor(source, target, data, points) {
        this.source = source;
        this.target = target;
        this.data = data;
        this.points = points;
    }
}
/**
 * The concrete implementation backing {@link Dag}.
 */
class LayoutDag {
    constructor(roots) {
        if (roots) {
            this.proots = roots;
        }
    }
    [Symbol.iterator]() {
        return this.idescendants()[Symbol.iterator]();
    }
    iroots() {
        return fluent(def(this.proots));
    }
    roots() {
        return [...this.iroots()];
    }
    *gdepth() {
        const ch = (node) => node.ichildren();
        yield* dfs(ch, ...this.iroots());
    }
    *gbreadth() {
        const seen = new Set();
        let next = this.roots();
        let current = [];
        do {
            current = next.reverse();
            next = [];
            let node;
            while ((node = current.pop())) {
                if (!seen.has(node)) {
                    seen.add(node);
                    yield node;
                    next.push(...node.ichildren());
                }
            }
        } while (next.length);
    }
    *gbefore() {
        const numBefore = new Map();
        for (const node of this) {
            for (const child of node.ichildren()) {
                numBefore.set(child, (numBefore.get(child) || 0) + 1);
            }
        }
        const queue = this.roots();
        let node;
        while ((node = queue.pop())) {
            yield node;
            for (const child of node.ichildren()) {
                const before = def(numBefore.get(child));
                if (before > 1) {
                    numBefore.set(child, before - 1);
                }
                else {
                    queue.push(child);
                }
            }
        }
    }
    *gafter() {
        const queue = this.roots();
        const seen = new Set();
        let node;
        while ((node = queue.pop())) {
            if (seen.has(node)) {
                // noop
            }
            else if (node.ichildren().every((c) => seen.has(c))) {
                seen.add(node);
                yield node;
            }
            else {
                queue.push(node); // need to revisit after children
                queue.push(...node.ichildren());
            }
        }
    }
    idescendants(style = "depth") {
        if (style === "depth") {
            return fluent(this.gdepth());
        }
        else if (style === "breadth") {
            return fluent(this.gbreadth());
        }
        else if (style === "before") {
            return fluent(this.gbefore());
        }
        else if (style === "after") {
            return fluent(this.gafter());
        }
        else {
            throw new Error(`unknown iteration style: ${style}`);
        }
    }
    descendants(style = "depth") {
        return [...this.idescendants(style)];
    }
    ilinks() {
        return this.idescendants().flatMap((node) => node.ichildLinks());
    }
    links() {
        return [...this.ilinks()];
    }
    size() {
        return this.idescendants().reduce((s) => s + 1, 0);
    }
    sum(callback) {
        const descendantVals = new Map();
        for (const [index, node] of this.idescendants("after").entries()) {
            const val = callback(node, index);
            const nodeVals = new Map();
            nodeVals.set(node, val);
            for (const child of node.ichildren()) {
                const childMap = def(descendantVals.get(child));
                for (const [child, v] of childMap.entries()) {
                    nodeVals.set(child, v);
                }
            }
            node.value = fluent(nodeVals.values()).reduce((a, b) => a + b);
            descendantVals.set(node, nodeVals);
        }
        return this;
    }
    count() {
        const leaves = new Map();
        for (const node of this.idescendants("after")) {
            if (node.ichildren()[Symbol.iterator]().next().done) {
                leaves.set(node, new Set([node]));
                node.value = 1;
            }
            else {
                const nodeLeaves = new Set();
                for (const child of node.ichildren()) {
                    const childLeaves = def(leaves.get(child));
                    for (const leaf of childLeaves) {
                        nodeLeaves.add(leaf);
                    }
                }
                leaves.set(node, nodeLeaves);
                node.value = nodeLeaves.size;
            }
        }
        return this;
    }
    height() {
        for (const node of this.idescendants("after")) {
            node.value = Math.max(0, ...node.ichildren().map((child) => def(child.value) + 1));
        }
        return this;
    }
    depth() {
        const parents = new Map();
        for (const node of this) {
            for (const child of node.ichildren()) {
                const pars = parents.get(child);
                if (pars) {
                    pars.push(node);
                }
                else {
                    parents.set(child, [node]);
                }
            }
        }
        for (const node of this.idescendants("before")) {
            node.value = Math.max(0, ...(parents.get(node) || []).map((par) => def(par.value) + 1));
        }
        return this;
    }
    *gsplit() {
        // create parents
        const parents = new Map();
        for (const node of this) {
            for (const child of node.ichildren()) {
                const pars = parents.get(child);
                if (pars) {
                    pars.push(node);
                }
                else {
                    parents.set(child, [node]);
                }
            }
        }
        // "children" function that returns children and parents
        function* graph(node) {
            yield* node.ichildren();
            yield* parents.get(node) || [];
        }
        // dfs over roots, tracing parents too
        const available = new Set(this.iroots());
        for (const root of this.iroots()) {
            if (!available.delete(root))
                continue;
            const connected = [root];
            for (const node of dfs(graph, root)) {
                if (available.delete(node)) {
                    connected.push(node);
                }
            }
            // yield all connected roots
            yield connected.length > 1 ? new LayoutDag(connected) : connected[0];
        }
    }
    isplit() {
        return fluent(this.gsplit());
    }
    split() {
        return [...this.isplit()];
    }
    connected() {
        const iter = this.isplit()[Symbol.iterator]();
        let { done } = iter.next();
        assert(!done);
        ({ done } = iter.next());
        return !!done;
    }
}
/**
 * Concrete implementation of {@link DagNode}.
 */
class LayoutDagNode extends LayoutDag {
    constructor(data) {
        super();
        this.data = data;
        this.dataChildren = [];
    }
    // NOTE everything extends from iroots, so by overriding this, we allow
    // dagnodes to work effectively
    iroots() {
        return fluent([this]);
    }
    *gchildren() {
        for (const { child } of this.dataChildren) {
            yield child;
        }
    }
    ichildren() {
        return fluent(this.gchildren());
    }
    children() {
        return [...this.ichildren()];
    }
    *gchildLinks() {
        for (const { child, data, points } of this.dataChildren) {
            yield new LayoutLink(this, child, data, points);
        }
    }
    ichildLinks() {
        return fluent(this.gchildLinks());
    }
    childLinks() {
        return [...this.ichildLinks()];
    }
    // NOTE these are simpler for a single node, so we override
    isplit() {
        return fluent([this]);
    }
    split() {
        return [this];
    }
    connected() {
        return true;
    }
}
/**
 * Verify an ID is a valid ID.
 */
function verifyId(id) {
    if (typeof id !== "string") {
        throw new Error(`id is supposed to be string but got type ${typeof id}`);
    }
    return id;
}
/**
 * Verify a DAG is valid.
 */
function verifyDag(roots) {
    // test that there are roots
    if (!roots.length) {
        throw new Error("dag contained no roots; this often indicates a cycle");
    }
    // make sure there's no duplicate edges
    for (const node of new LayoutDag(roots)) {
        const childIdSet = new Set(node.ichildren());
        if (childIdSet.size !== node.ichildren().length) {
            throw new Error(js `node '${node.data}' contained duplicate children`);
        }
    }
    // test that dag is free of cycles
    // we attempt to take every unique path from each root and see if we ever see
    // a node again
    const seen = new Set(); // already processed
    const past = new Set(); // seen down this path
    let rec = null;
    /** visit nodes returning cycle if found */
    function visit(node) {
        if (seen.has(node)) {
            return [];
        }
        else if (past.has(node)) {
            rec = node;
            return [node];
        }
        else {
            past.add(node);
            let result = [];
            for (const child of node.ichildren()) {
                result = visit(child);
                if (result.length)
                    break;
            }
            past.delete(node);
            seen.add(node);
            if (result.length && rec !== null)
                result.push(node);
            if (rec === node)
                rec = null;
            return result;
        }
    }
    for (const root of roots) {
        const msg = visit(root);
        if (msg.length) {
            const cycle = msg
                .reverse()
                .map(({ data }) => js `'${data}'`)
                .join(" -> ");
            throw new Error(`dag contained a cycle: ${cycle}`);
        }
    }
}
function buildConnect(operators) {
    function connect(data) {
        if (!data.length) {
            throw new Error("can't connect empty data");
        }
        const nodes = new Map();
        const hasParents = new Set();
        for (const [i, datum] of data.entries()) {
            // create dag
            const source = verifyId(operators.sourceId(datum, i));
            let sourceNode = nodes.get(source);
            if (sourceNode === undefined) {
                sourceNode = new LayoutDagNode({ id: source });
                nodes.set(source, sourceNode);
            }
            const target = verifyId(operators.targetId(datum, i));
            let targetNode = nodes.get(target);
            if (targetNode === undefined) {
                targetNode = new LayoutDagNode({ id: target });
                nodes.set(target, targetNode);
            }
            if (source !== target || !operators.single) {
                sourceNode.dataChildren.push(new LayoutChildLink(targetNode, datum));
                hasParents.add(target);
            }
        }
        const roots = [];
        for (const [id, node] of nodes.entries()) {
            if (!hasParents.has(id)) {
                roots.push(node);
            }
        }
        verifyDag(roots);
        return roots.length > 1 ? new LayoutDag(roots) : roots[0];
    }
    function sourceId(id) {
        if (id === undefined) {
            return operators.sourceId;
        }
        else {
            const { sourceId: _ } = operators, rest = __rest(operators, ["sourceId"]);
            return buildConnect(Object.assign(Object.assign({}, rest), { sourceId: id }));
        }
    }
    connect.sourceId = sourceId;
    function targetId(id) {
        if (id === undefined) {
            return operators.targetId;
        }
        else {
            const { targetId: _ } = operators, rest = __rest(operators, ["targetId"]);
            return buildConnect(Object.assign(Object.assign({}, rest), { targetId: id }));
        }
    }
    connect.targetId = targetId;
    function single(val) {
        if (val === undefined) {
            return operators.single;
        }
        else {
            return buildConnect(Object.assign(Object.assign({}, operators), { single: val }));
        }
    }
    connect.single = single;
    return connect;
}
function isZeroString(d) {
    try {
        return typeof d[0] === "string";
    }
    catch (_a) {
        return false;
    }
}
function defaultSourceId(d) {
    if (isZeroString(d)) {
        return d[0];
    }
    else {
        throw new Error(`default source id expected datum[0] to be a string but got datum: ${d}`);
    }
}
function isOneString(d) {
    try {
        return typeof d[1] === "string";
    }
    catch (_a) {
        return false;
    }
}
function defaultTargetId(d) {
    if (isOneString(d)) {
        return d[1];
    }
    else {
        throw new Error(`default target id expected datum[1] to be a string but got datum: ${d}`);
    }
}
/**
 * Creates a new {@link ConnectOperator} with the default settings. This is
 * bundled as {@link dagConnect}
 */
export function connect(...args) {
    if (args.length) {
        throw new Error(`got arguments to connect(${args}), but constructor takes no aruguments. ` +
            "These were probably meant as data which should be called as connect()(...)");
    }
    else {
        return buildConnect({
            sourceId: defaultSourceId,
            targetId: defaultTargetId,
            single: false
        });
    }
}
function buildHierarchy(operators) {
    function hierarchy(...data) {
        if (!data.length) {
            throw new Error("must pass in at least one node");
        }
        const mapping = new Map();
        const queue = [];
        function nodify(datum) {
            let node = mapping.get(datum);
            if (node === undefined) {
                node = new LayoutDagNode(datum);
                mapping.set(datum, node);
                queue.push(node);
            }
            return node;
        }
        const roots = data.map(nodify);
        let node;
        let i = 0;
        while ((node = queue.pop())) {
            node.dataChildren = (operators.childrenData(node.data, i++) || []).map(([childDatum, linkDatum]) => new LayoutChildLink(nodify(childDatum), linkDatum));
        }
        // verifty roots are roots
        const rootSet = new Set(roots);
        for (const node of mapping.values()) {
            for (const child of node.ichildren()) {
                if (rootSet.delete(child) && operators.roots) {
                    throw new Error(js `node '${node.data}' pointed to a root`);
                }
            }
        }
        // NOTE if rootSet is empty then we have a cycle, but we defer to verifyDag
        // to get better printing
        const froots = rootSet.size && rootSet.size !== roots.length ? [...rootSet] : roots;
        // create dag
        verifyDag(froots);
        return froots.length > 1 ? new LayoutDag(froots) : froots[0];
    }
    function children(childs) {
        if (childs === undefined) {
            return operators.children;
        }
        else {
            return buildHierarchy({
                children: childs,
                childrenData: wrapChildren(childs),
                roots: operators.roots
            });
        }
    }
    hierarchy.children = children;
    function childrenData(data) {
        if (data === undefined) {
            return operators.childrenData;
        }
        else {
            return buildHierarchy({
                children: wrapChildrenData(data),
                childrenData: data,
                roots: operators.roots
            });
        }
    }
    hierarchy.childrenData = childrenData;
    function roots(val) {
        if (val === undefined) {
            return operators.roots;
        }
        else {
            return buildHierarchy(Object.assign(Object.assign({}, operators), { roots: val }));
        }
    }
    hierarchy.roots = roots;
    return hierarchy;
}
function wrapChildren(children) {
    function wrapped(d, i) {
        return (children(d, i) || []).map((d) => [d, undefined]);
    }
    wrapped.wrapped = children;
    return wrapped;
}
function wrapChildrenData(childrenData) {
    function wrapped(d, i) {
        return (childrenData(d, i) || []).map(([d]) => d);
    }
    wrapped.wrapped = childrenData;
    return wrapped;
}
function hasChildren(d) {
    try {
        const children = d.children;
        return children === undefined || children instanceof Array;
    }
    catch (_a) {
        return false;
    }
}
function defaultChildren(d) {
    if (hasChildren(d)) {
        return d.children;
    }
    else {
        throw new Error(js `default children function expected datum to have a children field but got: ${d}`);
    }
}
/**
 * Constructs a new {@link HierarchyOperator} with default settings. This is
 * bundled as {@link dagHierarchy}.
 */
export function hierarchy(...args) {
    if (args.length) {
        throw new Error(`got arguments to hierarchy(${args}), but constructor takes no aruguments. ` +
            "These were probably meant as data which should be called as hierarchy()(...)");
    }
    else {
        return buildHierarchy({
            children: defaultChildren,
            childrenData: wrapChildren(defaultChildren),
            roots: true
        });
    }
}
function buildStratify(operators) {
    function stratify(data) {
        if (!data.length)
            throw new Error("can't stratify empty data");
        const mapping = new Map();
        for (const [i, datum] of data.entries()) {
            const nid = verifyId(operators.id(datum, i));
            const pdata = operators.parentData(datum, i) || [];
            const node = new LayoutDagNode(datum);
            if (mapping.has(nid)) {
                throw new Error(`found a duplicate id: ${id}`);
            }
            else {
                mapping.set(nid, [node, pdata]);
            }
        }
        const roots = [];
        for (const [node, pdata] of mapping.values()) {
            for (const [pid, linkData] of pdata) {
                const info = mapping.get(pid);
                if (!info)
                    throw new Error(`missing id: ${pid}`);
                const [par] = info;
                par.dataChildren.push(new LayoutChildLink(node, linkData));
            }
            if (!pdata.length) {
                roots.push(node);
            }
        }
        verifyDag(roots);
        return roots.length > 1 ? new LayoutDag(roots) : roots[0];
    }
    function id(op) {
        if (op === undefined) {
            return operators.id;
        }
        else {
            const { id: _ } = operators, rest = __rest(operators, ["id"]);
            return buildStratify(Object.assign(Object.assign({}, rest), { id: op }));
        }
    }
    stratify.id = id;
    function parentData(data) {
        if (data === undefined) {
            return operators.parentData;
        }
        else {
            const { parentIds: _, parentData: __ } = operators, rest = __rest(operators, ["parentIds", "parentData"]);
            return buildStratify(Object.assign(Object.assign({}, rest), { parentIds: wrapParentData(data), parentData: data }));
        }
    }
    stratify.parentData = parentData;
    function parentIds(ids) {
        if (ids === undefined) {
            return operators.parentIds;
        }
        else {
            const { parentIds: _, parentData: __ } = operators, rest = __rest(operators, ["parentIds", "parentData"]);
            return buildStratify(Object.assign(Object.assign({}, rest), { parentIds: ids, parentData: wrapParentIds(ids) }));
        }
    }
    stratify.parentIds = parentIds;
    return stratify;
}
function wrapParentIds(parentIds) {
    function wrapper(d, i) {
        return (parentIds(d, i) || []).map((id) => [id, undefined]);
    }
    wrapper.wrapped = parentIds;
    return wrapper;
}
function wrapParentData(parentData) {
    function wrapper(d, i) {
        return (parentData(d, i) || []).map(([id]) => id);
    }
    wrapper.wrapped = parentData;
    return wrapper;
}
function hasId(d) {
    try {
        return typeof d.id === "string";
    }
    catch (_a) {
        return false;
    }
}
function defaultId(data) {
    if (hasId(data)) {
        return data.id;
    }
    else {
        throw new Error(js `default id function expected datum to have an id field but got '${data}'`);
    }
}
function hasParentIds(d) {
    try {
        const parentIds = d.parentIds;
        return (parentIds === undefined ||
            (parentIds instanceof Array &&
                parentIds.every((id) => typeof id === "string")));
    }
    catch (_a) {
        return false;
    }
}
function defaultParentIds(d) {
    if (hasParentIds(d)) {
        return d.parentIds;
    }
    else {
        throw new Error(`default parentIds function expected datum to have a parentIds field but got: ${d}`);
    }
}
/**
 * Constructs a new {@link StratifyOperator} with the default settings. This is
 * bundled as {@link dagStratify}.
 */
export function stratify(...args) {
    if (args.length) {
        throw new Error(`got arguments to stratify(${args}), but constructor takes no aruguments. ` +
            "These were probably meant as data which should be called as stratify()(...)");
    }
    else {
        return buildStratify({
            id: defaultId,
            parentIds: defaultParentIds,
            parentData: wrapParentIds(defaultParentIds)
        });
    }
}
