/**
 * Three built-in methods exist to turn existing raw data into {@link Dag}s:
 * 1. {@link HierarchyOperator} - when the data already has a dag structure.
 * 2. {@link StratifyOperator} - when the dag has a tabular structure, referencing parents by id.
 * 3. {@link ConnectOperator} - when the dag has a link structure and is specified as pairs of nodes.
 *
 * @module
 */
import { Dag } from ".";
import { Up } from "../utils";
/***********
 * General *
 ***********/
/**
 * The interface for getting a node id from data. The function must return an
 * appropriate unique string id for given datum. This operator will only be
 * called once for each input.
 *
 * `i` will increment in the order data are processed.
 *
 * This is used in {@link StratifyOperator.id}, {@link
 * ConnectOperator.sourceId}, and {@link ConnectOperator.targetId}.
 */
export interface IdOperator<Datum = never> {
    (d: Datum, i: number): string;
}
/** get datum type from IdOperator */
declare type IdDatum<O extends IdOperator> = Parameters<O>[0];
/***********
 * Connect *
 ***********/
/**
 * The default node data on dags built using {@link ConnectOperator}
 */
export interface ConnectDatum {
    id: string;
}
/**
 * The operators that parametrize {@link ConnectOperator}
 */
interface ConnectOperators {
    sourceId: IdOperator;
    targetId: IdOperator;
}
/**
 * The constraint applied to data passed into {@link ConnectOperator}
 * conditioned on its operators.
 */
declare type ConnectLinkDatum<Ops extends ConnectOperators> = IdDatum<Ops["sourceId"]> & IdDatum<Ops["targetId"]>;
/**
 * An operator that constructs a {@link Dag} from link data.
 *
 * Create a default connect operator with {@link connect}. The accessor for the
 * {@link sourceId | source id string}, {@link targetId | target id string},
 * and whether to allow {@link single} nodes can all be modified.
 *
 * Links in the dag will have the same data as the objects passed in, and nodes
 * will have the ids referenced as either the source or the target.
 */
export interface ConnectOperator<Ops extends ConnectOperators> {
    /**
     * Construct a {@link Dag} from the specified data. The data should be an array of
     * data elements that contain info about links in the graph. For example:
     *
     * ```json
     * [
     *   ["Eve", "Cain"],
     *   ["Eve", "Seth"],
     *   ["Seth", "Enos"],
     *   ["Seth", "Noam"],
     *   ["Eve", "Abel"],
     *   ["Eve", "Awan"]
     * ]
     * ```
     */
    <L extends ConnectLinkDatum<Ops>>(data: readonly L[]): Dag<ConnectDatum, L>;
    /**
     * Sets the source accessor to the given {@link IdOperator} and returns this
     * {@link ConnectOperator}. This should return the source id of the link
     * data. The default accessor is:
     *
     * ```js
     * function sourceAccessor(link) {
     *   return link[0];
     * }
     * ```
     */
    sourceId<NewId extends IdOperator>(id: NewId): ConnectOperator<Up<Ops, {
        sourceId: NewId;
    }>>;
    /** Gets the current sourceId accessor. */
    sourceId(): Ops["sourceId"];
    /**
     * Sets the target accessor to the given {@link IdOperator} and returns this
     * {@link ConnectOperator}. This should return the target id of the link
     * data. The default accessor is:
     *
     * ```js
     * function sourceAccessor(link) {
     *   return link[1];
     * }
     * ```
     */
    targetId<NewId extends IdOperator>(id: NewId): ConnectOperator<Up<Ops, {
        targetId: NewId;
    }>>;
    /** Gets the current targetId accessor. */
    targetId(): Ops["targetId"];
    /**
     * Sets the allowance for single nodes. If enabled and the source id equals
     * the target id, then a single node with no parents will be created.
     * Otherwise a self loop will be created which will result in an error. Note
     * only single nodes without parents or children need to be specified this
     * way, otherwise any other connection to a node will creat it. (default: false)
     */
    single(val: boolean): ConnectOperator<Ops>;
    /** get the current single node setting. */
    single(): boolean;
}
interface ZeroString {
    readonly [0]: string;
}
interface OneString {
    readonly [1]: string;
}
/**
 * Creates a new {@link ConnectOperator} with the default settings. This is
 * bundled as {@link dagConnect}
 */
export declare function connect(...args: never[]): ConnectOperator<{
    sourceId: IdOperator<ZeroString>;
    targetId: IdOperator<OneString>;
}>;
/*************
 * Hierarchy *
 *************/
/**
 * The interface for getting child data from node data. This function must
 * return data for every child given the data for the current node. `i` will
 * increment for each node processed.
 *
 * Can be modified with {@link children}.
 */
export interface ChildrenOperator<NodeDatum> {
    (d: NodeDatum, i: number): readonly NodeDatum[] | undefined;
}
/**
 * The interface for getting children data and associated link data from node
 * data. This function must return data for every child of the given node, and
 * data for link between the two. `i` will increment for each node processesed.
 *
 * Can be modified with {@link childrenData}.
 */
export interface ChildrenDataOperator<NodeDatum, LinkDatum = unknown> {
    (d: NodeDatum, i: number): readonly (readonly [NodeDatum, LinkDatum])[] | undefined;
}
/**
 * What gets returned by {@link childrenData}() when {@link children} is set.
 */
export interface WrappedChildrenOperator<NodeDatum, Children extends ChildrenOperator<NodeDatum>> extends ChildrenDataOperator<NodeDatum, undefined> {
    wrapped: Children;
}
/**
 * What gets returned by {@link children}() when {@link childrenData} is set.
 */
export interface WrappedChildrenDataOperator<NodeDatum, ChildrenData extends ChildrenDataOperator<NodeDatum>> extends ChildrenOperator<NodeDatum> {
    wrapped: ChildrenData;
}
interface HierarchyOperators<NodeDatum> {
    children: ChildrenOperator<NodeDatum>;
    childrenData: ChildrenDataOperator<NodeDatum, unknown>;
}
declare type HierarchyLinkDatum<N, Ops extends HierarchyOperators<N>> = Exclude<ReturnType<Ops["childrenData"]>, undefined>[number][1];
declare type ChildrenHierarchyOperator<NodeDatum, Children extends ChildrenOperator<NodeDatum>> = HierarchyOperator<NodeDatum, {
    children: Children;
    childrenData: WrappedChildrenOperator<NodeDatum, Children>;
}>;
declare type ChildrenDataHierarchyOperator<NodeDatum, ChildrenData extends ChildrenDataOperator<NodeDatum>> = HierarchyOperator<NodeDatum, {
    children: WrappedChildrenDataOperator<NodeDatum, ChildrenData>;
    childrenData: ChildrenData;
}>;
/**
 * An operator that constructs a {@link Dag} from hierarchy data.
 *
 * A default operator can be created with {@link hierarchy}. How to access a
 * piece of data's {@link children} or {@link childrenData | children with
 * associated link data} can be altered. Similarly you can disable whether to
 * check that all initial nodes are actually {@link roots}.
 *
 * Data passed in will become node data, if {@link childrenData} is specified,
 * then link data will also be included. This method uses object identity, so
 * for two nodes to point to the same object, they must both return the same
 * object in their children.
 */
export interface HierarchyOperator<NodeDatum, Ops extends HierarchyOperators<NodeDatum>> {
    /**
     * Construct a {@link Dag} from the specified root nodes.
     * Each root node must be an object representing a root node.
     * For example:
     *
     * ```json
     * {
     *   "id": "Eve",
     *     "children": [
     *     {
     *       "id": "Cain"
     *     },
     *     {
     *       "id": "Seth",
     *       "children": [
     *       {
     *         "id": "Enos"
     *       },
     *       {
     *         "id": "Noam"
     *       }
     *       ]
     *     },
     *     {
     *       "id": "Abel"
     *     },
     *     {
     *       "id": "Awan",
     *       "children": [
     *       {
     *         "id": "Enoch"
     *       }
     *       ]
     *     },
     *     {
     *       "id": "Azura"
     *     }
     *   ]
     * }
     * ```
     *
     * The children of each node will be further traversed until the entire dag
     * is explored. Unless {@link roots} is set to false, all initial roots must
     * be roots, i.e. they cann't occur in an call to children.
     *
     */
    (...data: readonly NodeDatum[]): Dag<NodeDatum, HierarchyLinkDatum<NodeDatum, Ops>>;
    /**
     * Sets the children accessor to the given {@link ChildrenOperator} and
     * returns a new hierarchy operator. The default operator is:
     *
     * ```js
     * function children(d) {
     *   return d.children;
     * }
     * ```
     */
    children<NewDatum, NewChildren extends ChildrenOperator<NewDatum>>(ids: NewChildren & ChildrenOperator<NewDatum>): ChildrenHierarchyOperator<NewDatum, NewChildren>;
    /**
     * Gets the current {@link ChildrenOperator}, If {@link childrenData} was specified,
     * this will return a {@link WrappedChildrenOperatoe | wrapped version} that
     * returns only the children of that operator.
     */
    children(): Ops["children"];
    /**
     * Sets the childrenData accessor to the given {@link ChildrenDataOperator} and
     * returns a new hierarchy operator.
     */
    childrenData<NewDatum, NewChildrenData extends ChildrenDataOperator<NewDatum>>(data: NewChildrenData & ChildrenDataOperator<NewDatum>): ChildrenDataHierarchyOperator<NewDatum, NewChildrenData>;
    /**
     * Get the current childrenData operator. If {@link children} was specified, this
     * will return a {@link WrappedChildrenDataOperator | wrapped version} that
     * returns undefined data.
     */
    childrenData(): Ops["childrenData"];
    /**
     * Specify if only roots should be passed in, if true, hierarchy will throw
     * an error if a non-root was passed initially. (default: true)
     */
    roots(val: boolean): HierarchyOperator<NodeDatum, Ops>;
    /** get the current roots value. */
    roots(): boolean;
}
interface HasChildren {
    readonly children?: readonly HasChildren[] | undefined;
}
/**
 * Constructs a new {@link HierarchyOperator} with default settings. This is
 * bundled as {@link dagHierarchy}.
 */
export declare function hierarchy(...args: never[]): ChildrenHierarchyOperator<HasChildren, ChildrenOperator<HasChildren>>;
/************
 * Stratify *
 ************/
/**
 * The interface for getting the parent ids from data. This must return an
 * array of the ids of every parent of this node. `i` will increment in the
 * order nodes are processed.
 *
 * This can be modified with the {@link parentIds} method.
 */
export interface ParentIdsOperator<NodeDatum = never> {
    (d: NodeDatum, i: number): readonly string[] | undefined;
}
/**
 * The interface for getting the parent ids and link data from the current node
 * data. This must return an array of parent ids coupled with data for the link
 * between this node and the parent id.
 *
 * This can be modified with the {@link parentData} method.
 */
export interface ParentDataOperator<NodeDatum = never, LinkDatum = unknown> {
    (d: NodeDatum, i: number): readonly (readonly [string, LinkDatum])[] | undefined;
}
declare type OpNodeDatum<Op extends IdOperator | ParentIdsOperator | ParentDataOperator> = Parameters<Op>[0];
declare type StratifyNodeDatum<Ops extends StratifyOperators> = OpNodeDatum<Ops["id"]> & OpNodeDatum<Ops["parentData"]>;
declare type StratifyLinkDatum<Ops extends StratifyOperators> = Exclude<ReturnType<Ops["parentData"]>, undefined>[number][1];
/**
 * What gets returned by {@link parentData}() when {@link parentIds} is set.
 */
export interface WrappedParentIdsOperator<ParentIds extends ParentIdsOperator> extends ParentDataOperator<OpNodeDatum<ParentIds>, undefined> {
    wrapped: ParentIds;
}
/**
 * What gets returned by {@link parentIds}() when {@link parentData} is set.
 */
export interface WrappedParentDataOperator<ParentData extends ParentDataOperator> extends ParentIdsOperator<OpNodeDatum<ParentData>> {
    wrapped: ParentData;
}
interface StratifyOperators {
    id: IdOperator;
    parentIds: ParentIdsOperator;
    parentData: ParentDataOperator;
}
declare type UpIds<Ops extends StratifyOperators, ParentIds extends ParentIdsOperator> = Up<Ops, {
    parentIds: ParentIds;
    parentData: WrappedParentIdsOperator<ParentIds>;
}>;
declare type UpData<Ops extends StratifyOperators, ParentData extends ParentDataOperator> = Up<Ops, {
    parentData: ParentData;
    parentIds: WrappedParentDataOperator<ParentData>;
}>;
/**
 * The operator that constructs a {@link Dag} from stratified tabularesque
 * data.
 *
 * Create a default operator with {@link stratify}. The accessors for a node's
 * {@link id} or {@link parentIds | parents' ids} can be altered, or {@link
 * parentData} can be specified to attach link data to each edge.
 */
export interface StratifyOperator<Ops extends StratifyOperators> {
    /**
     * Construct a dag from the specified `data`. The data should be an array
     * of data elements that contain information about their parents' ids. For
     * example:
     *
     * ```json
     * [
     *   {
     *     "id": "Eve"
     *   },
     *   {
     *     "id": "Cain",
     *     "parentIds": ["Eve"]
     *   },
     *   {
     *     "id": "Seth",
     *     "parentIds": ["Eve"]
     *   },
     *   {
     *     "id": "Enos",
     *     "parentIds": ["Seth"]
     *   },
     *   {
     *     "id": "Noam",
     *     "parentIds": ["Seth"]
     *   },
     *   {
     *     "id": "Abel",
     *     "parentIds": ["Eve"]
     *   },
     *   {
     *     "id": "Awan",
     *     "parentIds": ["Eve"]
     *   },
     *   {
     *     "id": "Enoch",
     *     "parentIds": ["Eve"]
     *   },
     *   {
     *     "id": "Azura",
     *     "parentIds": ["Eve"]
     *   }
     * ]
     * ```
     */
    <N extends StratifyNodeDatum<Ops>>(data: readonly N[]): Dag<N, StratifyLinkDatum<Ops>>;
    /**
     * Sets the id accessor to the given {@link IdOperator} and returns a
     * {@link StratifyOperator}. The default operator is:
     *
     * ```js
     * function id(d) {
     *   return d.id;
     * }
     * ```
     */
    id<NewId extends IdOperator>(id: NewId): StratifyOperator<Up<Ops, {
        id: NewId;
    }>>;
    /**
     * Gets the current id accessor.
     */
    id(): Ops["id"];
    /**
     * Sets the parentIds accessor to the given {@link ParentIdsOperator}
     * and returns an update operator. The default operator is:
     *
     * ```js
     * function parentIds(d) {
     *   return d.parentIds;
     * }
     * ```
     */
    parentIds<NewParentIds extends ParentIdsOperator>(ids: NewParentIds): StratifyOperator<UpIds<Ops, NewParentIds>>;
    /**
     * Gets the current parent ids accessor.  If {@link parentData} was passed, the
     * returned function will {@link WrappedParentDataOperator | wrap} that to
     * just return the ids.
     */
    parentIds(): Ops["parentIds"];
    /**
     * Sets the parentData accessor to the given {@link ParentDataOperator} and
     * returns an updated operator.
     */
    parentData<NewParentData extends ParentDataOperator>(data: NewParentData): StratifyOperator<UpData<Ops, NewParentData>>;
    /**
     * Gets the current parentData accessor. If {@link parentIds} was passed, this
     * will {@link WrappedParentIdsOperator | wrap} that to just return the ids
     * with `undefined` data.
     */
    parentData(): Ops["parentData"];
}
interface HasId {
    readonly id: string;
}
interface HasParentIds {
    readonly parentIds?: readonly string[] | undefined;
}
/**
 * Constructs a new {@link StratifyOperator} with the default settings. This is
 * bundled as {@link dagStratify}.
 */
export declare function stratify(...args: never[]): StratifyOperator<{
    id: IdOperator<HasId>;
    parentIds: ParentIdsOperator<HasParentIds>;
    parentData: WrappedParentIdsOperator<ParentIdsOperator<HasParentIds>>;
}>;
export {};
