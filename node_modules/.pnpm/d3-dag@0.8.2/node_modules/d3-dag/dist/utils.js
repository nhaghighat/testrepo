/**
 * General utilities for use throughout the package
 *
 * @internal
 * @module
 */
/** helper for verifying things aren't undefined */
export function def(val) {
    if (val !== undefined) {
        return val;
    }
    else {
        throw new Error("internal error: got unexpected undefined value");
    }
}
/** assert something */
export function assert(statement) {
    if (!statement) {
        throw new Error("internal error: failed assert");
    }
}
/** determines if two sets intersect */
export function setIntersect(first, second) {
    if (second.size < first.size) {
        [second, first] = [first, second];
    }
    for (const element of first) {
        if (second.has(element)) {
            return true;
        }
    }
    return false;
}
/** replacer for serializing possibly circular json */
export function getCircularReplacer() {
    const seen = new WeakSet();
    return (key, value) => {
        if (typeof value === "object" && value !== null) {
            if (seen.has(value)) {
                return "[circular]";
            }
            seen.add(value);
        }
        return value;
    };
}
/** format tag for converting inputs to json */
export function js(strings, ...values) {
    const [base, ...rest] = strings;
    return [base]
        .concat(...rest.map((str, i) => [
        JSON.stringify(values[i], getCircularReplacer()),
        str
    ]))
        .join("");
}
/** iterate over bigrams of an array */
export function* bigrams(array) {
    let [first, ...rest] = array;
    for (const second of rest) {
        yield [first, second];
        first = second;
    }
}
/** depth first search for arbitrary types */
export function* dfs(children, ...queue) {
    const seen = new Set();
    let node;
    while ((node = queue.pop())) {
        if (seen.has(node))
            continue;
        yield node;
        seen.add(node);
        queue.push(...children(node));
    }
}
