import { assert } from "../utils";
import { greedy } from "./greedy";
/** @internal */
function buildOperator(width, height) {
    function zherebkoCall(dag) {
        var _a, _b;
        // topological sort
        const ordered = [...dag.idescendants("before")];
        const maxLayer = ordered.length - 1;
        if (maxLayer === 0) {
            // center if only one node
            const [node] = ordered;
            node.x = width / 2;
            node.y = height / 2;
            return;
        }
        // get link indices
        const indices = greedy(ordered);
        // map to coordinates
        // include at least one "gap" in each side even if graph is as line
        let minIndex = -1;
        let maxIndex = 1;
        for (const { source, target } of dag.ilinks()) {
            const index = (_a = indices.get(source)) === null || _a === void 0 ? void 0 : _a.get(target);
            if (index === undefined)
                continue; // assumed short link
            minIndex = Math.min(minIndex, index);
            maxIndex = Math.max(maxIndex, index);
        }
        // assign node positions
        const layerSize = height / maxLayer;
        for (const [layer, node] of ordered.entries()) {
            node.x = (-minIndex * width) / (maxIndex - minIndex);
            node.y = layer * layerSize;
        }
        // assign link points
        for (const { source, target, points } of dag.ilinks()) {
            points.length = 0;
            assert(source.x !== undefined && source.y !== undefined);
            assert(target.x !== undefined && target.y !== undefined);
            points.push({ x: source.x, y: source.y });
            const index = (_b = indices.get(source)) === null || _b === void 0 ? void 0 : _b.get(target);
            if (index !== undefined) {
                // assumed long link
                const x = ((index - minIndex) / (maxIndex - minIndex)) * width;
                const y1 = source.y + layerSize;
                const y2 = target.y - layerSize;
                if (y2 - y1 > layerSize / 2) {
                    points.push({ x: x, y: y1 }, { x: x, y: y2 });
                }
                else {
                    points.push({ x: x, y: y1 });
                }
            }
            points.push({ x: target.x, y: target.y });
        }
    }
    function size(sz) {
        if (sz === undefined) {
            return [width, height];
        }
        else {
            const [newWidth, newHeight] = sz;
            return buildOperator(newWidth, newHeight);
        }
    }
    zherebkoCall.size = size;
    // TODO add nodeSized
    return zherebkoCall;
}
/**
 * Create a new {@link ZherebkoOperator} with default settings.
 */
export function zherebko(...args) {
    if (args.length) {
        throw new Error(`got arguments to zherebko(${args}), but constructor takes no aruguments.`);
    }
    return buildOperator(1, 1);
}
