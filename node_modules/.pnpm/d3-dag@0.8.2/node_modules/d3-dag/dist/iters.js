/**
 * Stopgap for esnext iterable features
 *
 * We use this over `fluent-iterable` because that package is out of date, and
 * there's no need to invoke another dependency just for this.
 *
 * @module
 */
import Denque from "denque";
/**
 * The implementation of {@link FluentIterable}
 */
class LazyFluentIterable {
    constructor(base) {
        this.base = base;
    }
    [Symbol.iterator]() {
        return this.base[Symbol.iterator]();
    }
    *gconcat(...others) {
        yield* this;
        for (const iter of others) {
            yield* iter;
        }
    }
    concat(...others) {
        return fluent(this.gconcat(...others));
    }
    *gentries() {
        let index = 0;
        for (const element of this) {
            yield [index++, element];
        }
    }
    entries() {
        return fluent(this.gentries());
    }
    every(callback) {
        return !this.some((elem, ind) => !callback(elem, ind));
    }
    fill(val) {
        return this.map(() => val);
    }
    *gfilter(callback) {
        for (const [index, element] of this.gentries()) {
            if (callback(element, index)) {
                yield element;
            }
        }
    }
    filter(callback) {
        return fluent(this.gfilter(callback));
    }
    find(callback) {
        return this.filter(callback).shift();
    }
    findIndex(callback) {
        for (const [index, element] of this.gentries()) {
            if (callback(element, index)) {
                return index;
            }
        }
        return -1;
    }
    *gflatMap(callback) {
        for (const [index, element] of this.gentries()) {
            yield* callback(element, index);
        }
    }
    flatMap(callback) {
        return fluent(this.gflatMap(callback));
    }
    forEach(callback) {
        for (const [index, element] of this.gentries()) {
            callback(element, index);
        }
    }
    includes(query, fromIndex = 0) {
        return this.indexOf(query, fromIndex) >= 0;
    }
    indexOf(query, fromIndex = 0) {
        if (fromIndex < 0) {
            let index = 0;
            const queue = new Denque();
            for (const elem of this) {
                if (index >= -fromIndex) {
                    queue.shift();
                }
                queue.push(elem);
                index++;
            }
            const ind = queue.toArray().indexOf(query);
            if (ind === -1) {
                return -1;
            }
            else {
                return ind + index + fromIndex;
            }
        }
        else {
            for (const [index, element] of this.gentries()) {
                if (index >= fromIndex && element === query) {
                    return index;
                }
            }
            return -1;
        }
    }
    join(separator = ",") {
        return [...this].join(separator);
    }
    *gkeys() {
        let index = 0;
        for (const _ of this) {
            yield index++;
        }
    }
    keys() {
        return fluent(this.gkeys());
    }
    lastIndexOf(query, fromIndex = Infinity) {
        let lastIndex = -1;
        if (fromIndex < 0) {
            const queue = new Denque();
            for (const [index, element] of this.gentries()) {
                if (element === query) {
                    queue.push(index);
                }
                const next = queue.peekFront();
                if (next !== undefined && next <= index + fromIndex + 1) {
                    queue.shift();
                    lastIndex = next;
                }
            }
        }
        else {
            for (const [index, element] of this.gentries()) {
                if (index <= fromIndex && element === query) {
                    lastIndex = index;
                }
            }
        }
        return lastIndex;
    }
    get length() {
        return this.reduce((a) => a + 1, 0);
    }
    *gmap(callback) {
        for (const [index, element] of this.gentries()) {
            yield callback(element, index);
        }
    }
    map(callback) {
        return fluent(this.gmap(callback));
    }
    pop() {
        let last;
        for (last of this) {
            // noop
        }
        return last;
    }
    push(...items) {
        return this.concat(items);
    }
    reduce(callback, initialValue) {
        if (initialValue === undefined) {
            const call = callback;
            let first = true;
            let accumulator = undefined;
            for (const [index, element] of this.gentries()) {
                if (first) {
                    accumulator = element;
                    first = false;
                }
                else {
                    accumulator = call(accumulator, element, index);
                }
            }
            if (first) {
                throw new TypeError("Reduce of empty iterable with no initial value");
            }
            return accumulator;
        }
        else {
            const call = callback;
            let accumulator = initialValue;
            for (const [index, element] of this.gentries()) {
                accumulator = call(accumulator, element, index);
            }
            return accumulator;
        }
    }
    reverse() {
        return fluent([...this].reverse());
    }
    shift() {
        for (const val of this) {
            return val;
        }
        return undefined;
    }
    *gslice(start, end) {
        for (const [index, element] of this.gentries()) {
            if (index >= end) {
                break; // no more elements
            }
            else if (index >= start) {
                yield element;
            }
        }
    }
    *gnegslice(start, end) {
        const queue = new Denque();
        const pop = start - end;
        for (const [index, elem] of this.gentries()) {
            if (index >= pop) {
                yield queue.shift();
                queue.push(elem);
            }
            else if (index >= start) {
                queue.push(elem);
            }
        }
    }
    slice(start = 0, end = Infinity) {
        if (start < 0) {
            let index = 0;
            const queue = new Denque();
            for (const elem of this) {
                if (index >= -start) {
                    queue.shift();
                }
                queue.push(elem);
                index++;
            }
            const array = queue.toArray();
            const num = end - index - start;
            if (end < 0) {
                return fluent(array.slice(0, end));
            }
            else if (num > 0) {
                return fluent(array.slice(0, num));
            }
            else {
                return fluent();
            }
        }
        else if (end < 0) {
            return fluent(this.gnegslice(start, end));
        }
        else {
            return fluent(this.gslice(start, end));
        }
    }
    some(callback) {
        for (const [index, element] of this.gentries()) {
            if (callback(element, index)) {
                return true;
            }
        }
        return false;
    }
    sort(compare) {
        return fluent([...this].sort(compare));
    }
    *gsplice(start, deleteCount, ...items) {
        for (const [index, element] of this.gentries()) {
            if (index === start) {
                yield* items;
            }
            if (index < start || index >= start + deleteCount) {
                yield element;
            }
        }
    }
    splice(start, deleteCount = 0, ...items) {
        return fluent(this.gsplice(start, deleteCount, ...items));
    }
    unshift(...items) {
        return fluent(items).concat(this);
    }
    values() {
        return this;
    }
}
/**
 * Create a fluent iterable from a source iterable
 */
export function fluent(seq = []) {
    return new LazyFluentIterable(seq);
}
